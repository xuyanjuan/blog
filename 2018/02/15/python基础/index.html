<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>Python基础 | Hexo</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/blog/yun.svg"><link rel="mask-icon" href="/blog/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/blog/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/blog/js/utils.js" as="script"><link rel="preload" href="/blog/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/blog/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"xucongming.gitee.io","root":"/blog/","title":"花卷的博客","version":"1.5.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/blog/css/hexo-theme-yun.css"><script src="/blog/js/utils.js"></script><script src="/blog/js/hexo-theme-yun.js"></script><meta name="description" content="五大数据类型常见操作列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 1. append 用于在列表末尾追加新的对象a &#x3D; [1, 2, 3]a.append(4)# result: [1, 2, 3, 4]# 2. count 方法统计某">
<meta property="og:type" content="article">
<meta property="og:title" content="Python基础">
<meta property="og:url" content="http://xucongming.gitee.io/blog/2018/02/15/python%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="五大数据类型常见操作列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 1. append 用于在列表末尾追加新的对象a &#x3D; [1, 2, 3]a.append(4)# result: [1, 2, 3, 4]# 2. count 方法统计某">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/01/mGWJefdCR9EaIlk.jpg">
<meta property="article:published_time" content="2018-02-15T02:46:25.000Z">
<meta property="article:modified_time" content="2018-02-15T02:46:25.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/01/mGWJefdCR9EaIlk.jpg"><script src="/blog/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/blog/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/blog/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/blog/about/" title="John Doe"><img width="96" loading="lazy" src="/blog/yun.png" alt="John Doe"></a><div class="site-author-name"><a href="/blog/about/">John Doe</a></div><span class="site-name">Hexo</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/blog/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/blog/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">14</span></a></div><div class="site-state-item"><a href="/blog/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">9</span></a></div><div class="site-state-item"><a href="/blog/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">13</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=epvxdq1sknJe9JMj6J1LsBw4a6cI_2ln&amp;jump_from=webapi" title="QQ 群 389401003" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/yunyoujun/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/yunyoujun/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/elpsycn" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.now.sh/" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-send-plane-2-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/blog/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">五大数据类型常见操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">1.3.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.5.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">1.6.</span> <span class="toc-text">可变不可变</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">三程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%8B%93%E5%B1%95%E5%9B%9E%E7%AD%94%E5%86%85%E5%AE%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text">进程定义拓展回答内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.3.</span> <span class="toc-text">进程和程序的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.4.</span> <span class="toc-text">多道编程概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.5.</span> <span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.6.</span> <span class="toc-text">进程间互相访问数据的四种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.1.7.</span> <span class="toc-text">为什么需要进程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E4%BC%98%E7%82%B9"><span class="toc-number">2.1.8.</span> <span class="toc-text">进程池优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BA%86%E8%BF%9B%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.9.</span> <span class="toc-text">有了进程为什么还要线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">线程的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%8B%93%E5%B1%95%E5%9B%9E%E7%AD%94%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.2.</span> <span class="toc-text">线程定义拓展回答内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E5%90%8C%E6%97%B6%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.4.</span> <span class="toc-text">for循环同时启动多个线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.5.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t-join-%EF%BC%9A-%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E9%83%BD%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9D%9F%E5%90%8E%E5%86%8D%E6%89%A7%E8%A1%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.6.</span> <span class="toc-text">t.join()： 实现所有线程都执行结束后再执行主线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setDaemon-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.7.</span> <span class="toc-text">setDaemon(): 守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.2.8.</span> <span class="toc-text">Semaphore(信号量)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%EF%BC%9A"><span class="toc-number">2.2.9.</span> <span class="toc-text">GIL全局解释器锁：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">2.2.10.</span> <span class="toc-text">线程锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BA%86GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">2.2.11.</span> <span class="toc-text">有了GIL全局解释器锁为什么还需要线程锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.12.</span> <span class="toc-text">死锁定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E9%94%81"><span class="toc-number">2.2.13.</span> <span class="toc-text">用户锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.2.14.</span> <span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%88%E8%BF%9B%E5%85%A5%E4%B8%8A%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是协程（进入上一次调用的状态）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">协程的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.3.3.</span> <span class="toc-text">协程的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.4.</span> <span class="toc-text">协程的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">三器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.2.</span> <span class="toc-text">装饰器的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3"><span class="toc-number">3.1.3.</span> <span class="toc-text">装饰器的简单理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%BB%84%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.4.</span> <span class="toc-text">装饰器组成方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.1.5.</span> <span class="toc-text">装饰器实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.6.</span> <span class="toc-text">装饰器使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">3.1.7.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">高阶函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">引用计数</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://xucongming.gitee.io/blog/blog/2018/02/15/python%E5%9F%BA%E7%A1%80/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Python基础</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2018-02-15 10:46:25" itemprop="dateCreated datePublished" datetime="2018-02-15T10:46:25+08:00">2018-02-15</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/blog/categories/Python/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Python</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/blog/tags/Python/" style="--text-color:#3776ab"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Python</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p><img src="https://i.loli.net/2021/02/01/mGWJefdCR9EaIlk.jpg" alt="20200826102636292.jpg" loading="lazy"></p>
<h1 id="五大数据类型常见操作"><a href="#五大数据类型常见操作" class="headerlink" title="五大数据类型常见操作"></a>五大数据类型常见操作</h1><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 1. append 用于在列表末尾追加新的对象</span><br><span class="line">a &#x3D; [1, 2, 3]</span><br><span class="line">a.append(4)</span><br><span class="line"># result: [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"># 2. count 方法统计某个元素在列表中出现的次数</span><br><span class="line">a &#x3D; [&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;aa&#39;, &#39;aa&#39;]</span><br><span class="line">print(a.count(&#39;aa&#39;))</span><br><span class="line"># result: 3</span><br><span class="line"></span><br><span class="line"># 3. extend 方法可以在列表的末尾一次性追加另一个序列中的多个值</span><br><span class="line">a &#x3D; [1, 2, 3]</span><br><span class="line">b &#x3D; [4, 5, 6]</span><br><span class="line">a.extend(b)</span><br><span class="line"># result: [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line"># 4. index 函数用于从列表中找出某个值第一个匹配项的索引位置</span><br><span class="line">a &#x3D; [1, 2, 3, 1]</span><br><span class="line">print(a.index(1))</span><br><span class="line"># result: 0</span><br><span class="line"></span><br><span class="line"># 5. insert 方法用于将对象插入到列表中</span><br><span class="line">a &#x3D; [1, 2, 3]</span><br><span class="line">a.insert(0, &#39;aa&#39;)</span><br><span class="line"># result: [&#39;aa&#39;, 1, 2, 3]</span><br><span class="line"></span><br><span class="line"># 6. pop 方法会移除列表中的一个元素（默认是最后一个），并且返回该元素的值</span><br><span class="line">a &#x3D; [1, 2, 3]</span><br><span class="line">a.pop()</span><br><span class="line">a.pop(0)</span><br><span class="line"># result: [1, 2]</span><br><span class="line"></span><br><span class="line"># 7. remove 方法用于移除列表中某一个值的第一个匹配项</span><br><span class="line">a &#x3D; [&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;aa&#39;]</span><br><span class="line">a.remove(&#39;aa&#39;)</span><br><span class="line"># result: [&#39;bb&#39;, &#39;cc&#39;, &#39;aa&#39;]</span><br><span class="line"></span><br><span class="line"># 8.reverse 方法将列表中的元素反向存放</span><br><span class="line">a &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">a.reverse()</span><br><span class="line"># result: [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span><br><span class="line"></span><br><span class="line"># 9. sort 方法用于在原位置对列表进行排序，意外着改变原来的列表，让其中的元素按一定顺序排列</span><br><span class="line">a &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3]</span><br><span class="line">a.sort()</span><br><span class="line"># result: [1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line"># 10. enumerate 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</span><br><span class="line">li &#x3D; [11, 22, 33]</span><br><span class="line">for k,v in enumerate(li, 1):</span><br><span class="line">	print(k, v)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. find查找子串，他返回子串所在位置的最左端索引,没有找到返回 -1 rfind()和find是一样的  只不过是从右往左查询</span><br><span class="line"></span><br><span class="line">a &#x3D; &#39;abcdefghijk&#39;</span><br><span class="line">print(a.find(&#39;abc&#39;))                   # result: 0</span><br><span class="line">print(a.find(&#39;abc&#39;, 10, 100))          # result: 11 指定查找的起始和结束查找位置</span><br><span class="line"></span><br><span class="line">2. join 方法是非常重要的字符串方法，他是 split方法的逆方法，用来连接序列中的元素，并且需要被连接的元素都必须是字符串</span><br><span class="line"></span><br><span class="line">a &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span><br><span class="line">print(&quot;+&quot;.join(a))                     # result: 1 + 2 + 3</span><br><span class="line"></span><br><span class="line"># 3. split 方法，是一个非常重要的字符串，他是 join的逆方法，用来将字符串分割成序列</span><br><span class="line"></span><br><span class="line">print(&#39;1 + 2 + 3 + 4&#39;.split(&#39;+&#39;))      # result: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]</span><br><span class="line"></span><br><span class="line"># 4. strip 方法返回去除首位空格（不包括内部）的字符串 lstrip()    去除左边的空格  rstrip()    去除右边的空格</span><br><span class="line"></span><br><span class="line">print(&quot;   test  test  &quot;.strip())       # result: &quot;test  test&quot;</span><br><span class="line"></span><br><span class="line"># 5. replace 方法返回某字符串所有匹配项均被替换之后的到字符串</span><br><span class="line"></span><br><span class="line">print(&quot;This is a test&quot;.replace(&#39;is&#39;, &#39;is_test&#39;))         # result: This_test is_test a test</span><br><span class="line"></span><br><span class="line"># 6.capitalize 将字符串的首字母转换成大写  title()   将每个单词的首字母大写</span><br><span class="line"></span><br><span class="line">s &#x3D; &#39;aBdkndfkFFD&#39;</span><br><span class="line">print(s.capitalize())</span><br><span class="line"># result: &#39;Abdkndfkffd&#39;</span><br><span class="line"></span><br><span class="line"># 7.startswith()   以xxx开头 结果返回true或者false  endswith()   以xxx结尾</span><br><span class="line"></span><br><span class="line">a &#x3D; &#39;huajian&#39;</span><br><span class="line">print(a.startswith(&#39;hua&#39;))</span><br><span class="line"># result: True</span><br><span class="line"></span><br><span class="line"># 8.upper()    小转大  lower()   大 转 小</span><br><span class="line"></span><br><span class="line">a &#x3D; &#39;huajian&#39;</span><br><span class="line">print(a.upper())</span><br><span class="line"># result: HUAJIAN</span><br><span class="line"></span><br><span class="line"># 9.center()    将字符串放在中间  返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</span><br><span class="line"></span><br><span class="line">a &#x3D; &#39;huajian&#39;</span><br><span class="line">print(a.center(10))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isalpha()    判断字符串是否都是字母</span><br><span class="line">isdigit()   判断字符串全是数字</span><br><span class="line">isalnum()   判断字符串 数字&#x2F;字母&#x2F;字母加数字</span><br><span class="line">isspace()   判断字符串全是空格</span><br><span class="line">rjust()     将字符串向右对齐</span><br><span class="line">ljust()     将字符串向左对齐</span><br></pre></td></tr></table></figure>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 1. clear 方法清除字典中所有的项，这是一个原地操作，所以无法返回值（或者说返回 None）</span><br><span class="line">d &#x3D; &#123;&#39;name&#39;: &quot;tom&quot;&#125;</span><br><span class="line">d.clear()</span><br><span class="line">print(d)  </span><br><span class="line"># result: &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 2. fromkeys 方法使用给定的键 建立新的字典，每个键都对应一个默认的值 None</span><br><span class="line">print(&#123;&#125;.fromkeys([&#39;name&#39;, &#39;age&#39;]))</span><br><span class="line"># result: &#123;&#39;age&#39;:None, &#39;name&#39;:None&#125;</span><br><span class="line"></span><br><span class="line"># 3. get 方法是个更轻松的访问字典项的方法，如果视图访问字典中不存在的项时不会报错仅会   返回：None</span><br><span class="line">d &#x3D; &#123;&#39;Tom&#39;: 8777, &#39;jack&#39;: 8888, &#39;Fly&#39;: 6666&#125;</span><br><span class="line">print(d.get(&#39;Tom&#39;))               	    # result: 8777</span><br><span class="line">print(d.get(&#39;not_exist&#39;))           	# result: None</span><br><span class="line"></span><br><span class="line"># 4. for 循环字典的三种方法</span><br><span class="line">d &#x3D; &#123;&#39;Tom&#39;: 8777, &#39;Jack&#39;: 8888, &#39;Fly&#39;: 6666&#125;</span><br><span class="line">for k, v in d.items():</span><br><span class="line">	print(k, v)</span><br><span class="line"></span><br><span class="line">for k in d.values():</span><br><span class="line">	print(k)</span><br><span class="line"></span><br><span class="line">for k in d.keys():</span><br><span class="line">	print(k)</span><br><span class="line"></span><br><span class="line"># 5. pop 方法用于获得对应与给定键的值，然后将这个 &quot;键-值&quot; 对从字典中移除</span><br><span class="line">d &#x3D; &#123;&#39;Tom&#39;: 8777, &#39;Jack&#39;: 8888, &#39;Fly&#39;: 6666&#125;</span><br><span class="line">v &#x3D; d.pop(&#39;Tom&#39;)</span><br><span class="line">print(v)              # 8777</span><br><span class="line"></span><br><span class="line"># 6. setdefault 方法在某种程度上类似于 get方法，能够获得与给定键相关联的值，除此之外，setdefault 还能在字典中不含有给定键值的情况下设定相应的键值。</span><br><span class="line">d &#x3D; &#123;&#39;Tom&#39;: 8777, &#39;Jack&#39;:8888, &#39;Fly&#39;:6666&#125;</span><br><span class="line">d.setdefault(&#39;Tom&#39;)                  # result: 8777</span><br><span class="line">print(d.setdefault(&#39;Test&#39;))          # result: None</span><br><span class="line">print(d)                             # &#123;&#39;Fly&#39;: 6666, &#39;Jack&#39;: 8888, &#39;Tom&#39;: 8777, &#39;Test&#39;: None&#125;</span><br><span class="line"></span><br><span class="line"># 7. update 方法可以利用一个字典项更新另一个字典，提供的字典中的项会被添加到旧的字典中，如有相同的键则会被覆盖。</span><br><span class="line">d &#x3D; &#123;&#39;Tom&#39;: 8777, &#39;Jack&#39;: 8888, &#39;Fly&#39;: 6666&#125;</span><br><span class="line">a &#x3D; &#123;&#39;Tom&#39;: 100, &#39;Test&#39;: 119&#125;</span><br><span class="line">d.update(a)</span><br><span class="line">print(d)</span><br><span class="line"># result: &#123;&#39;Fly&#39;: 6666, &#39;Test&#39;: 119, &#39;Jack&#39;: 8888, &#39;Tom&#39;: 110&#125;</span><br><span class="line"></span><br><span class="line"># 8. 将两个列表组合成字典</span><br><span class="line">keys &#x3D; [&#39;a&#39;, &#39;b&#39;]</span><br><span class="line">values &#x3D; [1, 2]</span><br><span class="line">print(dict(zip(keys, values)))</span><br><span class="line"># result: &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tuple1 &#x3D; (9, 1, -4, 3, 7, 11, 3, 9, 0, 9)</span><br><span class="line">    </span><br><span class="line">   print(&#39;tuple1的长度 &#x3D; &#39;, len(tuple1))                  # tuple1的长度 &#x3D;  10</span><br><span class="line">    </span><br><span class="line">   print(&#39;tuple1里的最大值 &#x3D; &#39;, max(tuple1))              # tuple1里的最大值 &#x3D;  11</span><br><span class="line">    </span><br><span class="line">   print(&#39;tuple1里的最小值 &#x3D; &#39;, min(tuple1))             # tuple1里的最小值 &#x3D;  -4</span><br><span class="line">    </span><br><span class="line">   print(&#39;tuple1里9出现了&#123;&#125;次&#39;.format(tuple1.count(9)))   # tuple1里9这个元素一共出现了3次</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   # 元组不能被改变,包括元组不能翻转,元组不能排序</span><br><span class="line">    </span><br><span class="line">   print(tuple1.index(11))                           # 5 表示11这个元素的index为5</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">list_1 &#x3D; [1, 2, 3, 4, 5, 1, 2]</span><br><span class="line"></span><br><span class="line"># 1. 去重（去除 list_1 中重复元素1, 2）</span><br><span class="line">list_1 &#x3D; set(list_1)                     # 去重: &#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">print(list_1)</span><br><span class="line">list_2 &#x3D; set([4, 5, 6, 7, 8])</span><br><span class="line"></span><br><span class="line"># 2. 交集（在list_1 和 list_2中都有的元素 4, 5）</span><br><span class="line">print(list_1.intersection(list_2))       # 交集: &#123;4, 5&#125;</span><br><span class="line"></span><br><span class="line"># 3. 并集（在list_1 和 list_2中的元素全部打印出来，重复元素仅打印一次）</span><br><span class="line">print(list_1.union(list_2))              # 并集: &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span><br><span class="line"></span><br><span class="line"># 4. 交集</span><br><span class="line">print(list_1.difference(list_2))         # 差集：在list_1中有在 list_2中没有：&#123;1, 2 ,3&#125;</span><br><span class="line">print(list_2.difference(list_1))         # 差集：在list_1中有在 list_2中没有：&#123;8, 6, 7&#125;</span><br><span class="line"></span><br><span class="line"># 5.update()：添加集合</span><br><span class="line">a &#x3D; &#123;1,2,3,4,5,6&#125;</span><br><span class="line">a.update(&#123;11,22&#125;)</span><br><span class="line">print(a)                                  # &#123;1, 2, 3, 4, 5, 6, 11, 22&#125;</span><br><span class="line"></span><br><span class="line"># 6.add()：添加单个元素</span><br><span class="line">a &#x3D; &#123;1,2,3,4&#125;</span><br><span class="line">a.add(5)</span><br><span class="line">print(a)                                    #&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line"></span><br><span class="line"># 7.pop()：删除一个元素（由于集合是无序的所以无法指定索引进行删除）</span><br><span class="line">a &#x3D; &#123;1,2,3,4&#125;</span><br><span class="line">a.pop()</span><br><span class="line">print(a)                                    # &#123;2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line"># 8.remove()：指定删除集合中具体的元素</span><br><span class="line">a &#x3D; &#123;1,2,3,4&#125;</span><br><span class="line">a.pop(2)</span><br><span class="line">print(a)                                    # &#123;1, 3, 4&#125;</span><br><span class="line"></span><br><span class="line"># 9.clear()：清空集合</span><br><span class="line">a &#x3D; &#123;1,2,3,4&#125;</span><br><span class="line">a.clear()</span><br><span class="line">print(a)                                    #&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变不可变"><a href="#可变不可变" class="headerlink" title="可变不可变"></a>可变不可变</h2><p><strong>不可变类型：数字 ，字符串 ，元组</strong><br><strong>可变类型：列表，字典</strong></p>
<h1 id="三程"><a href="#三程" class="headerlink" title="三程"></a>三程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p><strong>是什么</strong></p>
<p>1.进程是资源分配最小单位</p>
<p>2.一个运行起来的程序就是一个进程<br>什么是程序（程序是我们存储在硬盘里的代码、文件）<br>当我们双击图标，打开程序的时候，实际上就是通过I/O操作（读写）内存条里面<br>内存条就是我们所指的资源</p>
<p>3.进程之间内存独立，不能相互访问</p>
<h3 id="进程定义拓展回答内容"><a href="#进程定义拓展回答内容" class="headerlink" title="进程定义拓展回答内容"></a>进程定义拓展回答内容</h3><p>1.程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，这种执行的程序就称之为进程</p>
<p>2.程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念</p>
<p>3.在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。</p>
<p>4.进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p>
<p>5.进程之间有自己独立的内存，各进程之间不能相互访问</p>
<p>6.创建一个新线程很简单，创建新进程需要对父进程进行复制</p>
<h3 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h3><p>1.程序只是一个普通文件，是一个机器代码指令和数据的集合，所以，程序是一个静态的实体</p>
<p>2.而进程是程序运行在数据集上的动态过程，进程是一个动态实体，它应创建而产生，应调度执行因等待资源或事件而被处于等待状态，因完成任务而被撤消</p>
<p>3.进程是系统进行资源分配和调度的一个独立单位</p>
<p>4.一个程序对应多个进程，一个进程为多个程序服务（两者之间是多对多的关系）</p>
<p>5.一个程序执行在不同的数据集上就成为不同的进程，进程可以控制 块 来唯一标识每个程序</p>
<h3 id="多道编程概念"><a href="#多道编程概念" class="headerlink" title="多道编程概念"></a>多道编程概念</h3><ul>
<li>多道编程： 在计算机内存中同时存放几道相互独立的程序，他们共享系统资源，相互穿插运行</li>
<li>单道编程： 计算机内存中只允许一个的程序运行<blockquote>
<p>进程具有独立的内存空间，所以没有办法相互通信</p>
</blockquote>
</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>python提供了多种进程通信的方式，主要Queue和Pipe这两种方式，Queue用 于多个进程间实现通信，Pipe是两个进程的通信。</p>
<ul>
<li>Queue有两个方法：</li>
</ul>
<ol>
<li>Put方法：以插入数据到队列中</li>
<li>Get方法：从队列读取并且删除一个元素</li>
</ol>
<ul>
<li><p>Pipe常用于两个进程，两个进程分别位于管道的两端<br>Pipe方法返回（conn1,conn2）代表一个管道的两个端，Pipe方法有duplex参数，默认为True，即全双工模式，若为FALSE，conn1只负责接收信息，conn2负责发送，</p>
</li>
<li><p>managers</p>
</li>
<li><p>RabbitMQ、redis等</p>
</li>
</ul>
<h3 id="进程间互相访问数据的四种方法"><a href="#进程间互相访问数据的四种方法" class="headerlink" title="进程间互相访问数据的四种方法"></a>进程间互相访问数据的四种方法</h3><blockquote>
<p>不同进程间内存是不共享的，所以互相之间不能访问对方数据</p>
</blockquote>
<p>1.利用Queues实现父进程到子进程（或子进程间）的数据传递<br>2.使用管道pipe实现两个进程间数据传递<br>3.Managers实现很多进程间数据共享<br>4.借助redis中间件进行数据共享</p>
<h3 id="为什么需要进程池"><a href="#为什么需要进程池" class="headerlink" title="为什么需要进程池"></a>为什么需要进程池</h3><ul>
<li>一次性开启指定数量的进程</li>
<li>如果有十个进程，有一百个任务，一次可以处理多少个（一次性只能处理十个）</li>
<li>防止进程开启数量过多导致服务器压力过大</li>
<li>开进程池是为了效率,进程直接的切换是属于IO调度，每个进程的内存空间都有自己的寄存器，堆栈和文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from  multiprocessing import Process,Pool</span><br><span class="line">import time,os</span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in the process&quot;,os.getpid()) #打印子进程的pid</span><br><span class="line">return i+100</span><br><span class="line"></span><br><span class="line">def call(arg):</span><br><span class="line">print(&#39;--&gt;exec done:&#39;,arg,os.getpid())</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    pool &#x3D; Pool(3)                      #进程池最多允许5个进程放入进程池</span><br><span class="line">    print(&quot;主进程pid：&quot;,os.getpid())     #打印父进程的pid</span><br><span class="line">    for i in range(10):</span><br><span class="line">       #用法1 callback作用是指定只有当Foo运行结束后就执行callback调用的函数,父进程调用的callback函数</span><br><span class="line">        pool.apply_async(func&#x3D;foo, args&#x3D;(i,),callback&#x3D;call)</span><br><span class="line">        #用法2 串行 启动进程不在用Process而是直接用pool.apply()</span><br><span class="line">        # pool.apply(func&#x3D;foo, args&#x3D;(i,))</span><br><span class="line">    print(&#39;end&#39;)</span><br><span class="line">    pool.close()    #关闭pool</span><br><span class="line">    pool.join()     #进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="进程池优点"><a href="#进程池优点" class="headerlink" title="进程池优点"></a>进程池优点</h3><blockquote>
<p>不仅仅减少了IO而且还减少了内存。<br>他语言的进程池还可以根据服务器的压力来增减，有着上限和下限</p>
</blockquote>
<p><strong>建议：超过五个进程就用进程池</strong></p>
<h3 id="有了进程为什么还要线程"><a href="#有了进程为什么还要线程" class="headerlink" title="有了进程为什么还要线程"></a>有了进程为什么还要线程</h3><p>1、进程优点：</p>
<p>提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率</p>
<p>2、进程的两个重要缺点</p>
<p>a. 第一点：进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</p>
<p>b. 第二点：进程在执行的过程中如果阻塞，即使进程中有些工作不依赖于输入的数据，也将无法执行（例如等待输入，整个进程就会挂起）。</p>
<p>c. 例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、又能监听其它人给你发的消息</p>
<p>d. 你会说，操作系统不是有分时么？分时是指在不同进程间的分时呀</p>
<p>e. 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，你的qq还是只能同时干一件事呀</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a>线程的定义</h3><p>1、线程是系统调度的最小单位</p>
<p>2、同进程下线程资源共享</p>
<p>3、进程无法自己执行，只有通过线程操作CPU，内存</p>
<p>4、为了保证数据安全，必须使用线程锁</p>
<h3 id="线程定义拓展回答内容"><a href="#线程定义拓展回答内容" class="headerlink" title="线程定义拓展回答内容"></a>线程定义拓展回答内容</h3><p>1、线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位</p>
<p>2、一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务</p>
<p>3、无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行</p>
<p>4、进程本身是无法自己执行的，要操作cpu，必须创建一个线程，线程是一系列指令的集合</p>
<p>5、所有在同一个进程里的线程是共享同一块内存空间的，不同进程间内存空间不同</p>
<p>6、同一个进程中的各线程可以相互访问资源，线程可以操作同进程中的其他线程，但进程仅能操作子进程</p>
<p>7、两个进程想通信，必须要通过一个中间代理</p>
<p>8、对主线程的修改可能回影响其他子线程，对主进程修改不会影响其他进程因为进程间内存相互独立，但是同一进程下的线程共享内存</p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>1、进程包含线程</p>
<p>2、线程共享内存空间</p>
<p>3、进程内存是独立的（不可互相访问）</p>
<p>4、进程可以生成子进程，子进程之间互相不能互相访问（相当于在父级进程克隆两个子进程）</p>
<p>5、在一个进程里面线程之间可以交流。两个进程想通信，必须通过一个中间代理来实现</p>
<p>6、创建新线程很简单，创建新进程需要对其父进程进行克隆。</p>
<p>7、一个线程可以控制或操作同一个进程里面的其它线程。但进程只能操作子进程。</p>
<p>8、父进程可以修改不影响子进程，但不能修改。</p>
<p>9、线程可以帮助应用程序同时做几件事</p>
<h3 id="for循环同时启动多个线程"><a href="#for循环同时启动多个线程" class="headerlink" title="for循环同时启动多个线程"></a>for循环同时启动多个线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def sayhi(num): #定义每个线程要运行的函数</span><br><span class="line">    print(&quot;running on number:%s&quot; %num)</span><br><span class="line">    time.sleep(3)</span><br><span class="line">for i in range(50):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;sayhi,args&#x3D;(&#39;t-%s&#39;%i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li>GIL锁：</li>
</ul>
<p>全局解释锁，每次只能一个线程获得cpu的使用权：为了线程安全，也就是为了解决多线程之间的数据完整性和状态同步而加的锁，因为我们知道线程之间的数据是共享的。</p>
<ul>
<li>join()作用：</li>
</ul>
<p>在进程中可以阻塞主进程的执行, 直到等待子线程全部完成之后, 才继续运行主线程后面的代码</p>
<ul>
<li>setDaemon()：</li>
</ul>
<p>将该线程标记为守护线程或用户线程</p>
<h3 id="t-join-：-实现所有线程都执行结束后再执行主线程"><a href="#t-join-：-实现所有线程都执行结束后再执行主线程" class="headerlink" title="t.join()： 实现所有线程都执行结束后再执行主线程"></a>t.join()： 实现所有线程都执行结束后再执行主线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">start_time &#x3D; time.time()</span><br><span class="line"></span><br><span class="line">def sayhi(num): #定义每个线程要运行的函数</span><br><span class="line">    print(&quot;running on number:%s&quot; %num)</span><br><span class="line">    time.sleep(3)</span><br><span class="line">t_objs &#x3D; []    #将进程实例对象存储在这个列表中</span><br><span class="line">for i in range(50):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;sayhi,args&#x3D;(&#39;t-%s&#39;%i,))</span><br><span class="line">    t.start()          #启动一个线程，程序不会阻塞</span><br><span class="line">    t_objs.append(t)</span><br><span class="line">print(threading.active_count())    #打印当前活跃进程数量</span><br><span class="line">for t in t_objs: #利用for循环等待上面50个进程全部结束</span><br><span class="line">    t.join()     #阻塞某个程序</span><br><span class="line">print(threading.current_thread())    #打印执行这个命令进程</span><br><span class="line"></span><br><span class="line">print(&quot;----------------all threads has finished.....&quot;)</span><br><span class="line">print(threading.active_count())</span><br><span class="line">print(&#39;cost time:&#39;,time.time() - start_time)</span><br></pre></td></tr></table></figure>

<h3 id="setDaemon-守护线程"><a href="#setDaemon-守护线程" class="headerlink" title="setDaemon(): 守护线程"></a>setDaemon(): 守护线程</h3><p><strong>主线程退出时，需要子线程随主线程退</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">start_time &#x3D; time.time()</span><br><span class="line"></span><br><span class="line">def sayhi(num): #定义每个线程要运行的函数</span><br><span class="line">    print(&quot;running on number:%s&quot; %num)</span><br><span class="line">    time.sleep(3)</span><br><span class="line">for i in range(50):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;sayhi,args&#x3D;(&#39;t-%s&#39;%i,))</span><br><span class="line">    t.setDaemon(True)  #把当前线程变成守护线程，必须在t.start()前设置</span><br><span class="line">    t.start()          #启动一个线程，程序不会阻塞</span><br><span class="line">print(&#39;cost time:&#39;,time.time() - start_time)</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h3><p><strong>互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据</strong></p>
<p>比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去<br>作用就是同一时刻允许运行的线程数量</p>
<h3 id="GIL全局解释器锁："><a href="#GIL全局解释器锁：" class="headerlink" title="GIL全局解释器锁："></a>GIL全局解释器锁：</h3><p><strong>保证同一时间仅有一个线程对资源有操作权限</strong></p>
<blockquote>
<p>作用：在一个进程内，同一时刻只能有一个线程执行</p>
<p>说明：python多线程中GIL锁只是在CPU操作时（如：计算）才是串行的，其他都是并行的，所以比串行快很多</p>
</blockquote>
<p>1、为了解决不同线程同时访问同一资源时，数据保护问题，而产生了GIL</p>
<p>2、GIL在解释器的层面限制了程序在同一时间只有一个线程被CPU实际执行，而不管你的程序里实际开了多少条线程</p>
<p>3、CPython自己定义了一个全局解释器锁，同一时间仅仅有一个线程可以拿到这个数据</p>
<p>4、python之所以会产生这种不好的状况是因为python启用一个线程是调用操作系统原生线程，就是C接口</p>
<p>5、但是这仅仅是CPython这个版本的问题，在PyPy，中就没有这种缺陷</p>
<h3 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h3><p>1、当一个线程对某个资源进行CPU计算的操作时加一个线程锁，只有当前线程计算完成主动释放锁，其他线程才能对其操作</p>
<p>2、这样就可以防止还未计算完成，释放GIL锁后其他线程对这个资源操作导致混乱问题</p>
<p>3、线程锁本质把线程中的数据加了一把互斥锁</p>
<h3 id="有了GIL全局解释器锁为什么还需要线程锁"><a href="#有了GIL全局解释器锁为什么还需要线程锁" class="headerlink" title="有了GIL全局解释器锁为什么还需要线程锁"></a>有了GIL全局解释器锁为什么还需要线程锁</h3><p><strong>因为cpu是分时使用的</strong></p>
<p>GIL是限制同一个进程中只有一个线程进入Python解释器。</p>
<p>而线程锁是由于在线程进行数据操作时保证数据操作的安全性(同一个进程中线程之间可以共用信息，如果同时对数据进行操作，则会出现公共数据错误)</p>
<p>其实线程锁完全可以替代GIL，但是Python的后续功能模块都是加在GIL基础上的，所以无法更改或去掉GIL,这就是Python语言最大的bug…只能用多进程或协程改善，或者直接用其他语言写这部分</p>
<h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><p>两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</p>
<h3 id="用户锁"><a href="#用户锁" class="headerlink" title="用户锁"></a>用户锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line">lock &#x3D; threading.Lock()          #1 生成全局锁</span><br><span class="line">def addNum():</span><br><span class="line">    global num                  #2 在每个线程中都获取这个全局变量</span><br><span class="line">    print(&#39;--get num:&#39;,num )</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    lock.acquire()              #3 修改数据前加锁</span><br><span class="line">    num  -&#x3D; 1                   #4 对此公共变量进行-1操作</span><br><span class="line">    lock.release()              #5 修改后释放</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>使用以下模块创建线程池</strong><br>  使用threadpool模块，这是个python的第三方模块，支持python2和python3<br>  使用concurrent.futures模块，这个模块是python3中自带的模块，但是，python2.7以上版本也可以安装使用<br><strong>线程池实现并发:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def fetch_request(url):</span><br><span class="line">    result &#x3D; requests.get(url)</span><br><span class="line">    print(result.text)</span><br><span class="line"></span><br><span class="line">url_list &#x3D; [</span><br><span class="line">    &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,</span><br><span class="line">    &#39;https:&#x2F;&#x2F;www.google.com&#x2F;&#39;,         #google页面会卡住，知道页面超时后这个进程才结束</span><br><span class="line">    &#39;http:&#x2F;&#x2F;dig.chouti.com&#x2F;&#39;,          #chouti页面内容会直接返回，不会等待Google页面的返回</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pool &#x3D; ThreadPoolExecutor(10)            # 创建一个线程池，最多开10个线程</span><br><span class="line">for url in url_list:</span><br><span class="line">    pool.submit(fetch_request,url)       # 去线程池中获取一个线程，线程去执行fetch_request方法</span><br><span class="line"></span><br><span class="line">pool.shutdown(True)                      # 主线程自己关闭，让子线程自己拿任务执行</span><br></pre></td></tr></table></figure>

<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="什么是协程（进入上一次调用的状态）"><a href="#什么是协程（进入上一次调用的状态）" class="headerlink" title="什么是协程（进入上一次调用的状态）"></a>什么是协程（进入上一次调用的状态）</h3><p>1、协程，又称微线程，纤程，协程是一种用户态的轻量级线程。</p>
<p>2、线程的切换会保存到CPU的栈里，协程拥有自己的寄存器上下文和栈</p>
<p>3、协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</p>
<p>4、协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态</p>
<p>5、协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的（像yield一样）</p>
<p>6、协程能在单线程处理高并发</p>
<h3 id="协程的定义"><a href="#协程的定义" class="headerlink" title="协程的定义"></a>协程的定义</h3><p>1、协程在单线程下实现并发效果</p>
<p>2、协程遇IO自动切换</p>
<p>3、协程保留上一次调用状态</p>
<h3 id="协程的优点"><a href="#协程的优点" class="headerlink" title="协程的优点"></a>协程的优点</h3><p>1、无需线程上下文切换的开销</p>
<p>2、无需原子操作锁定及同步的开销，因为协程是串行的</p>
<p>3、方便切换控制流，简化编程模型</p>
<p>4、高并发，高扩展，低成本，一个cpu支持上万个协程没有问题，所以非常适合高并发处理</p>
<h3 id="协程的缺点"><a href="#协程的缺点" class="headerlink" title="协程的缺点"></a>协程的缺点</h3><ul>
<li>无法利用多核的优势，但是协程和进程配合就可以使协程运行在不同的cpu上，就可以利用 多核的优势，但是在现实中，大部分场景都没有这个需要</li>
<li>只要一个协程阻塞（Blocking），就会阻塞整个协程，因为协程是串行的,这个问题必须要解决，才能让协程大范围应用</li>
<li>解决方法：<br>如果遇到io操作，则进行协程切换,去执行其他的协程，可以用gevent来实现，具体的实现是这样的，<br>比如协程1通过os去读一个file，这个时候就是一个 io操作，在调用os的接口前，就会有一个列表，协议1的这个操作就会被注册到这个列表中，然后就切换到其他协程去处理；等待os拿到要读file后，也会把这个文件句柄放在这个列表中，然后等待在切换到<br>协程1的时候，协程1就可以直接从列表中拿到数据，这样就可以实现不阻塞了</li>
</ul>
<h1 id="三器"><a href="#三器" class="headerlink" title="三器"></a>三器</h1><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>装饰器(Decorators)是 Python 的一个重要部分。<br>简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短</strong></p>
<h3 id="装饰器的概念"><a href="#装饰器的概念" class="headerlink" title="装饰器的概念"></a>装饰器的概念</h3><ul>
<li>装饰器实际上就是一个函数</li>
<li>有两个特别之处，参数是一个函数。返回值是一个参数</li>
</ul>
<h3 id="装饰器的简单理解"><a href="#装饰器的简单理解" class="headerlink" title="装饰器的简单理解"></a>装饰器的简单理解</h3><ul>
<li><p>实际上就是为了给一个程序添加功能，但是该程序已经上线或者已被使用，<br>那么就不能大批量的修改源码，这样不现实，因此就产生了装饰器。</p>
</li>
<li><p>注意点：</p>
</li>
</ul>
<ol>
<li>不能修改被装饰的函数的源代码</li>
<li>不能修改被装饰的函数的调用方式</li>
</ol>
<h3 id="装饰器组成方式"><a href="#装饰器组成方式" class="headerlink" title="装饰器组成方式"></a>装饰器组成方式</h3><blockquote>
<p>函数+实参高阶函数+返回值高阶函数+嵌套函数+语法糖 = 装饰器</p>
</blockquote>
<ul>
<li>有关高阶函数的理解：</li>
</ul>
<p><strong>把一个函数名当作实参传给另外一个函数（”实参高阶函数“）</strong><br><strong>返回值中包含函数名（”返回值高阶函数“）</strong></p>
<ul>
<li>嵌套函数的理解：</li>
</ul>
<p><strong>嵌套函数指的是在函数内部定义一个函数，而不是调用。</strong></p>
<ul>
<li>语法糖：</li>
</ul>
<p><strong>写法：@xx ，一般写在函数的上方 通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</strong></p>
<h3 id="装饰器实例"><a href="#装饰器实例" class="headerlink" title="装饰器实例"></a>装饰器实例</h3><p><strong>使用高阶函数模拟装饰器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">def timer(func):</span><br><span class="line">	start_time &#x3D; time.time()</span><br><span class="line">	func()</span><br><span class="line">	print &#39;函数执行时间为&#39;, time.time() - start_time</span><br><span class="line">def test():</span><br><span class="line">	print &#39;开始执行test&#39;</span><br><span class="line">	time.sleep(3)</span><br><span class="line">	print &#39;test执行结束&#39;</span><br><span class="line">timer(test)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">开始执行test</span><br><span class="line">test执行结束</span><br><span class="line">函数执行时间为 3.00332999229</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>
<p><strong>计算运行时间装饰器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">def timer(func):   #timer(test1)  func&#x3D;test1</span><br><span class="line">    def deco(*args,**kwargs):</span><br><span class="line">        start_time &#x3D; time.time()</span><br><span class="line">        func(*args,**kwargs)      #run test1</span><br><span class="line">        stop_time &#x3D; time.time()</span><br><span class="line">        print(&quot;running time is %s&quot;%(stop_time-start_time))</span><br><span class="line">    return deco</span><br><span class="line">@timer     # test1&#x3D;timer(test1)</span><br><span class="line">def test1():</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    print(&quot;in the test1&quot;)</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure>
<p><strong>装饰无参函数，示例代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#装饰器装饰的函数无参数</span><br><span class="line">def timer(func):      #func其实指的就是test</span><br><span class="line">    def deco():</span><br><span class="line">        start &#x3D; time.time()</span><br><span class="line">        func()               #这里其实是对test的调用</span><br><span class="line">        stop &#x3D; time.time()</span><br><span class="line">        print (stop-start)</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@timer               #test函数使用装饰器</span><br><span class="line">def test():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print (&quot;test is running&quot;)</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">test is running</span><br><span class="line">2.003510952</span><br></pre></td></tr></table></figure>
<p><strong>装饰有参函数，示例代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#装饰器装饰的函数有参数</span><br><span class="line">def timer(func):</span><br><span class="line">    def deco(*args,**kwargs):    #添加可变参数*args和**kwargs</span><br><span class="line">        start &#x3D; time.time()</span><br><span class="line">        func(*args,**kwargs)      #这里也是一样，添加可变参数*args和**kwargs</span><br><span class="line">        stop &#x3D; time.time()</span><br><span class="line">        print (stop-start)</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def test(value):     #test函数有个参数value,正因为装饰器timer装饰的函数test有参数value,因此在timer中的有了可变参数</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print (&quot;test is running %s&quot; %value)</span><br><span class="line">test(&quot;22&quot;)</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">test is running 22</span><br><span class="line">2.00424408913</span><br></pre></td></tr></table></figure>
<p><strong>带参数的装饰器，示例代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#装饰器带参数</span><br><span class="line">def timer(parameter):</span><br><span class="line">    def out_wapper(func):</span><br><span class="line">        def wapper(*wargs,**kwargs):</span><br><span class="line">            if parameter &#x3D;&#x3D; &quot;task1&quot;:</span><br><span class="line">                start &#x3D; time.time()</span><br><span class="line">                func(*wargs,**kwargs)</span><br><span class="line">                stop &#x3D; time.time()</span><br><span class="line">                print (&quot;the task1 is run:&quot;,stop-start)</span><br><span class="line">            elif parameter &#x3D;&#x3D; &quot;task2&quot;:</span><br><span class="line">                func(*wargs, **kwargs)</span><br><span class="line">                print (&quot;the task2 is run:&quot;)</span><br><span class="line">        return wapper</span><br><span class="line">    return out_wapper</span><br><span class="line"></span><br><span class="line">@timer(parameter &#x3D; &quot;task1&quot;)</span><br><span class="line">def task1():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print &quot;in the task1&quot;</span><br><span class="line"></span><br><span class="line">@timer(parameter &#x3D; &quot;task2&quot;)</span><br><span class="line">def task2():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print &quot;in the task2&quot;</span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">in the task1</span><br><span class="line">(&#39;the task1 is run:&#39;, 2.002906084060669)</span><br><span class="line">in the task2</span><br><span class="line">the task2 is run:</span><br></pre></td></tr></table></figure>

<h3 id="装饰器使用场景"><a href="#装饰器使用场景" class="headerlink" title="装饰器使用场景"></a>装饰器使用场景</h3><ul>
<li>授权：装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中</li>
<li>日志：在记录日志的地方添加装饰器</li>
<li>缓存：通过装饰器获取缓存中的值</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>如果在一个函数的内部定义了另一个函数，外部的我们叫他外函数，内部的我们叫他内函数。那闭包就是，在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包</p>
</blockquote>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1></div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>John Doe</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://xucongming.gitee.io/blog/2018/02/15/python%E5%9F%BA%E7%A1%80/" title="Python基础">http://xucongming.gitee.io/blog/2018/02/15/python%E5%9F%BA%E7%A1%80/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/blog/2018/02/20/axios%E5%B0%81%E8%A3%85/" rel="prev" title="axios封装"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">axios封装</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/blog/2018/02/02/%E5%BE%AE%E5%8D%9A%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/" rel="next" title="微博三方登录"><span class="post-nav-text">微博三方登录</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> John Doe</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.2</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>